<html>
<head>
  <script type="text/javascript" src="musis.js"></script>
  <script type="text/javascript" src="adapters/play.js"></script>
  <script type="text/javascript" src="adapters/draw.js"></script>
  <script type="text/javascript" src="adapters/draw.trigger.js"></script>
  <script type="text/javascript" src="adapters/draw.star.js"></script>
  <script type="text/javascript" src="music/note.js"></script>
  <script type="text/javascript" src="music/voicing.js"></script>
  <script type="text/javascript" src="music/compose.js"></script>
  <script type="text/javascript" src="music/perform.js"></script>
  <script type="text/javascript" src="music/music.js"></script>
  <script type="text/javascript" src="metronome.js"></script>
  <script type="text/javascript" src="triggers.js"></script>
  <script type="text/javascript" src="stars.js"></script>
</head>
<body>
  <canvas id="canvas" width="960" height="540"></canvas>
  <script type="text/javascript">

/*
x Have mouse/touch handling in here and call through to js
x Make rendered object react to touch
x Have multiple trigger objects
x Touch-selecting issues
x Refactor drawing into adapter
x Arrange triggers
x Break draw and play out into own modules
x Have audio triggered by touchend
x When triggers play
 x fireworks
 x clear and start new triggers
x Use webgl canvas context
 x clear using webgl
 x basic drawing using webgl
 x trigger selected status
x Glows/effects for triggers and stars
x Refactoring and tidy up drawing
x Pulse and rhythm
 x experiment with noise from custom oscillator type...
 x metronome
x use metronome to place trigger sounds at exact beat times
x use pitchclass instead of note
x pass notes through to another module for voicing
 x voicing uses a composer to keep composing until next triggers are activated
 x first selected note is the bass
 x sensible spacing of other notes
x Play notes on next beat, not the one after
x Optimise stars: entire star lifetime should be in vertex shader; suggest ring buffer of star vertices; point sprites
 x setup shader uniform time and give each star a start time
 x velocity/gravity/fade/flicker/size
x Put adapters into an adapters folder
x Better voicing/composition
 x assign notes according to voice ranges
 x tidy chord composer: build a pipeline of functions for assigning notes to voices
 x put music stuff into a music folder
x Split music stuff up much better
 x triggers dont call voicing direct, instead they return the new harmony when activated
 x music module coordinates composing and playing music
 x seperate composition module with helpers like voicing...
 x move expandPCs and assignvoices back into music module
 x rename compose to perform
x First pc selected should be first reported and therefore the bass
x Note class
 x validate on construction
 x allow single string constructor eg: "C4"
 x toString function, and use it to output chosen voicing
* Better voice assignment
 x assign bass first
 x assign others ascending and fitting to voice ranges
 x generate all permutations of pc-to-voice
 x filter unacceptable ones
  x all PCs must be represented
 x generate further permutations of assigning PCs to notes within the voice range
 * score each
  x proximity to last note in same voice is good
  * consecutive fifths or octaves are bad
 x choose the best
 * refactor and tidy
* Switch from PCs to movable do solfege for triggers
 * set up a key class which can turn solfege into pitchclass in a given key
* Optimisation: pre-allocate all resources required for trigger drawing
* Consider how to manage composition: eg stopping playing notes when the harmony changes
 * So instead of blockChord composer playing chords on every beat, it can play per-bar or even held chords
* Generate analysis of next harmony for use later when composing melody etc
 * evaluate tension level as avg of tensions of individual notes
  ? or should be the max of the individual notes
  * in order: 1-5-3-6-2-4-7
 * chord root
* Consider downbeats: tell composition about downbeats so it can do things like ensure the bass changes on a downbeat etc
! when queuing up notes to play later, should queue up starbursts etc too
* Visual fx: build structures/lights etc
* Show selected triggers and current touch linked up with glowing, pulsing, smooth lines
* Evaluate quality of chords and progressions
* Extra notes and melody kick in if make good progressions
 * when hit tonic after perfect cadence, fill out the tonic chord for richer sound
* Gestures for arpeggio/block chord/voice leading etc
* Instruments from FFTs: http://www.sitepoint.com/using-fourier-transforms-web-audio-api/
* visual metronome indication
* tick sound when select a trigger
* Try getting motion blur by using alpha rect instead of clearing the back buffer (still need to clear z)
*/

musis.begin();

var canvas = document.getElementById("canvas");
var ctxGl = canvas.getContext("webgl");
if (!ctxGl) { ctxGl = canvas.getContext("experimental-webgl"); }
var tLast;
var frame = function (t) {
  if (tLast) {
    musis.frame(t, (t - tLast)/1000, ctxGl, canvas.width, canvas.height);
  }
  tLast = t;
  window.requestAnimationFrame(frame);
};
window.requestAnimationFrame(frame);

var touched = false;
var mousedown = false;
canvas.onmousedown = function (evt) {
  if (touched) { return; }
  mousedown = true;
  musis.touchstart(evt.clientX, evt.clientY);
};
canvas.onmousemove = function (evt) {
  if (touched) { return; }
  if (mousedown) {
    musis.touchmove(evt.clientX, evt.clientY);
  }
};
canvas.onmouseup = function (evt) {
  if (touched) { return; }
  musis.touchend();
  mousedown = false;
};

canvas.addEventListener("touchstart", function (evt) {
  touched = true;
  musis.touchstart(evt.changedTouches[0].clientX, evt.changedTouches[0].clientY);
});
canvas.addEventListener("touchmove", function (evt) {
  musis.touchmove(evt.changedTouches[0].clientX, evt.changedTouches[0].clientY);
});
canvas.addEventListener("touchend", function (evt) {
  musis.touchend();
});


  </script>
</body>
</html>
